package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/gorilla/context"
	"github.com/gorilla/sessions"
)

var output_channel chan string

type WebUser struct {
	Username string
	Password string
}

var session_store = sessions.NewCookieStore([]byte("super_secret_secret :D"))

var v view

func StartServer(ch chan string) {
	output_channel = ch

	dev := true

	v = newView(dev)

	// Expose the public directory for CSS / JS assets. We could just use
	// http.Handle on "/" and not do the StripPrefix but then the tmpls/
	// directory would also be accessible. The "Dir" function is generated by
	// the esc tool from "go generate"
	http.Handle("/public/", http.StripPrefix("/public", http.FileServer(Dir(dev, "/public"))))

	http.HandleFunc("/", index)
	http.HandleFunc("/login", login)
	http.HandleFunc("/dologin", doLogin)
	//http.HandleFunc("/api", api)

	output_channel <- "* Site running at localhost:8080\n"
	http.ListenAndServe(":8080", context.ClearHandler(http.DefaultServeMux))
}

func index(w http.ResponseWriter, r *http.Request) {
	t := v.Tmpl("index")
	fmt.Println(t.Execute(w, nil))
}

func login(w http.ResponseWriter, r *http.Request) {
	t := v.Tmpl("login")
	fmt.Println(t.Execute(w, nil))
}

func doLogin(w http.ResponseWriter, r *http.Request) {
	login_user := r.FormValue("username")
	login_pass := r.FormValue("password")

	lu := c.model.getWebUser(login_user)

	if login_pass == lu.Password {
		session, _ := session_store.Get(r, "mcman_session")
		session.Values["is_logged_in"] = login_user
		session.Save(r, w)
	}

	http.Redirect(w, r, "/", http.StatusFound)
}

func serveMcMan(w http.ResponseWriter, r *http.Request) {
	output := ""
	output_channel <- fmt.Sprint("HTTP Request: (", r.Method, ") ", r.URL, "\n")

	the_path := r.URL.Path
	the_path = strings.TrimPrefix(strings.ToLower(the_path), "/admin")

	if strings.HasPrefix(the_path, "/api/") {
		output = getAuthJSON(serveAPI, w, r)
	}
	fmt.Fprintf(w, output)
}

func serveAPI(w http.ResponseWriter, r *http.Request) string {
	_, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576))
	//body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576))
	if err != nil {
		panic(err)
	}
	if err := r.Body.Close(); err != nil {
		panic(err)
	}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	// What are we doing with this request?
	the_path := strings.TrimPrefix(strings.ToLower(r.URL.Path), "/admin")
	output_string := ""
	if strings.HasPrefix(the_path, "/api") {
		the_path = strings.TrimPrefix(the_path, "/api")
		if strings.HasPrefix(the_path, "/v1") {
			the_path = strings.TrimPrefix(the_path, "/v1")
			if strings.HasPrefix(the_path, "/whitelist") {
				output_string = handleWhitelist(r)
			} else if strings.HasPrefix(the_path, "/ops") {
				output_string = handleOps(r)
			} else if strings.HasPrefix(the_path, "/stop") {
				DoStopServer()
			} else if strings.HasPrefix(the_path, "/init") {
				v := WebUser{"br0xen", "asdf"}
				c.model.updateWebUser(&v)
			}
		}
	}
	return output_string
}

/* JSON Functions */
func getJSON(mid func(http.ResponseWriter, *http.Request) string,
	w http.ResponseWriter, r *http.Request) string {
	w.Header().Set("Content-Type", "application/json")
	return mid(w, r)
}

func getAuthJSON(mid func(http.ResponseWriter, *http.Request) string,
	w http.ResponseWriter, r *http.Request) string {
	session, _ := session_store.Get(r, "mcman_session")

	// Vaildate that the session is authenticated
	if val, ok := session.Values["is_logged_in"].(string); ok {
		switch val {
		case "":
			w.WriteHeader(403)
			w.Header().Set("Content-Type", "application/json")
			return "{\"status\":\"error\"}"
		default:
			w.Header().Set("Content-Type", "application/json")
			return mid(w, r)
		}
	} else {
		w.WriteHeader(403)
		w.Header().Set("Content-Type", "application/json")
		return "{\"status\":\"error\"}"
	}
	return ""
}

func handleOps(r *http.Request) string {
	if r.Method == "GET" {
		return getOps()
	} else if r.Method == "POST" {
		// Add posted user to Ops
	}
	return ""
}

func handleWhitelist(r *http.Request) string {
	if r.Method == "GET" {
		return getWhitelist()
	} else if r.Method == "POST" {
		// Add posted user to whitelist
	}
	return ""
}

/* HTML Functions */
func getAuthHTML(mid func(http.ResponseWriter, *http.Request) string,
	w http.ResponseWriter, r *http.Request) string {
	session, _ := session_store.Get(r, "mcman_session")

	// Vaildate that the session is authenticated
	if val, ok := session.Values["is_logged_in"].(string); ok {
		switch val {
		case "":
			http.Redirect(w, r, "/admin/login", http.StatusFound)
		default:
			return mid(w, r)
		}
	} else {
		http.Redirect(w, r, "/admin/login", http.StatusFound)
	}
	return ""
}

/* Data Functions */
func getOps() string {
	ret := "["
	num_users := 0
	for _, op_user := range GetConfig().Ops {
		if num_users > 0 {
			ret += ","
		}
		ret += fmt.Sprint("\"", op_user, "\"")
	}
	ret += "]"
	return ret
}

func getWhitelist() string {
	ret := "["
	num_users := 0
	for _, wl_user := range GetConfig().Whitelist {
		if num_users > 0 {
			ret += ","
		}
		ret += fmt.Sprint("\"", wl_user, "\"")
	}
	ret += "]"
	return ret
}
