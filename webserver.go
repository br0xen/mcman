package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/gorilla/handlers"
	"github.com/gorilla/mux"
	"github.com/gorilla/sessions"
	"github.com/justinas/alice"
)

type WebUser struct {
	Username string
	Password string
}

var sessionStore = sessions.NewCookieStore([]byte("super_secret_secret :D"))

var v view

func StartServer(dev bool) {
	v = newView(dev)

	r := mux.NewRouter()

	// Expose the public directory for CSS / JS assets. We could just use
	// http.Handle on "/" and not do the StripPrefix but then the tmpls/
	// directory would also be accessible. The "Dir" function is generated by
	// the esc tool from "go generate"
	r.PathPrefix("/public").Handler(
		http.StripPrefix("/public", http.FileServer(Dir(dev, "/public"))),
	)

	r.HandleFunc("/", index).Methods("GET")
	r.HandleFunc("/login", login).Methods("GET")
	r.HandleFunc("/dologin", doLogin).Methods("GET")
	r.HandleFunc("/stop", doStop).Methods("GET")

	a := r.PathPrefix("/api/v1").Subrouter()

	a.HandleFunc("/users/online", getOnlineUsers).Methods("GET")
	a.HandleFunc("/users/whitelist", getWhitelist).Methods("GET")
	a.HandleFunc("/users/ops", getOps).Methods("GET")
	a.HandleFunc("/stop", postStop).Methods("POST")

	chain := alice.New(loggingHandler).Then(r)

	output <- "* Site running at localhost:8080\n"
	http.ListenAndServe(":8080", chain)
}

type templateData struct {
	Menu []menuItem
}

type menuItem struct {
	Label    string
	Location string
	Icon     string
}

// createTemplateData Generates the Default template data
// (menus, etc.) and adds all data from `addData` into it
// as PageData
func createTemplateData(addData interface{}) interface{} {
	type pageData struct {
		templateData
		Data interface{}
	}
	ret := new(pageData)
	ret.Menu = []menuItem{
		{
			Label:    "Home",
			Location: "/",
			Icon:     "",
		}, {
			Label:    "About",
			Location: "/about",
			Icon:     "",
		}, {
			// TODO: Check for admin
			Label:    "Stop Server",
			Location: "/stop",
			Icon:     "",
		},
	}
	ret.Data = addData
	return ret
}

func index(w http.ResponseWriter, r *http.Request) {
	type indexData struct {
		OnlineUsers []MCUser
	}
	var err error
	tmpData := new(indexData)
	if tmpData.OnlineUsers, err = c.model.getOnlineMCUsers(); err != nil {
		fmt.Printf("> Error loading users: " + err.Error())
	}

	t := v.Tmpl("index")
	t.Execute(w, createTemplateData(tmpData))
}

func login(w http.ResponseWriter, r *http.Request) {
	t := v.Tmpl("login")
	t.Execute(w, nil)
}

func doLogin(w http.ResponseWriter, r *http.Request) {
	login_user := r.FormValue("username")
	login_pass := r.FormValue("password")

	lu, _ := c.model.getWebUser(login_user)

	if login_pass == lu.Password {
		session, _ := sessionStore.Get(r, "mcman_session")
		session.Values["is_logged_in"] = login_user
		session.Save(r, w)
	}
	t := v.Tmpl("index")
	t.Execute(w, nil)

	http.Redirect(w, r, "/", http.StatusFound)
}

func doStop(w http.ResponseWriter, r *http.Request) {
	DoStopServer()
	t := v.Tmpl("stopped")
	t.Execute(w, nil)
}

func serveAPI(w http.ResponseWriter, r *http.Request) string {
	return ""

	//if strings.HasPrefix(the_path, "/init") {
	//v := WebUser{"br0xen", "asdf"}
	//c.model.updateWebUser(&v)
	//}
}

/* JSON Functions */
func getJSON(mid func(http.ResponseWriter, *http.Request) string,
	w http.ResponseWriter, r *http.Request) string {
	w.Header().Set("Content-Type", "application/json")
	return mid(w, r)
}

func getAuthJSON(mid func(http.ResponseWriter, *http.Request) string,
	w http.ResponseWriter, r *http.Request) string {
	session, _ := sessionStore.Get(r, "mcman_session")

	// Vaildate that the session is authenticated
	if val, ok := session.Values["is_logged_in"].(string); ok {
		switch val {
		case "":
			w.WriteHeader(403)
			w.Header().Set("Content-Type", "application/json")
			return "{\"status\":\"error\"}"
		default:
			w.Header().Set("Content-Type", "application/json")
			return mid(w, r)
		}
	} else {
		w.WriteHeader(403)
		w.Header().Set("Content-Type", "application/json")
		return "{\"status\":\"error\"}"
	}
	return ""
}

func getOnlineUsers(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	var err error
	var onlineUsers []MCUser
	if onlineUsers, err = c.model.getOnlineMCUsers(); err != nil {
		fmt.Fprintf(w, "{\"status\":\"error\",\"message\":\"Error loading online users\"}")
	}
	if err = json.NewEncoder(w).Encode(onlineUsers); err != nil {
		log.Println(err)
	}
}

func getOps(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if err := json.NewEncoder(w).Encode(c.Ops); err != nil {
		log.Println(err)
	}
}

func getWhitelist(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	if err := json.NewEncoder(w).Encode(c.Whitelist); err != nil {
		log.Println(err)
	}
}

func postStop(w http.ResponseWriter, r *http.Request) {
	DoStopServer()
}

func loggingHandler(h http.Handler) http.Handler {
	return handlers.LoggingHandler(os.Stdout, h)
}
